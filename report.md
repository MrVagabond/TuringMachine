FLA Course Project Report
====

Part I & II
----
(1) main函数基本流程
step1: 读入.tm文件，对其进行parse，生成中间表示格式（更加格式化的IR）；
step2: 读入IR，生成多带图灵机tm；
step3: tm读入输入input，运行并判定input是否属于该图灵机识别的语言。

Parser类实现step1，得到的IR保存在Parser类的成员数据中，并对外提供next_token()成员函数。
TM类实现图灵机的数据与操作，该类的成员数据包含State类的数组、Tape类的数组、head数组，表明状态和纸带的信息。

(2) 使用中间表示IR
最一开始我尝试直接解析.tm文件来生成图灵机，但我发现这样做虽然可行但是有很多复杂的细节。我想要OJ一样的格式化的输入，这个.tm文件还是有点不必要的复杂。碰巧这学期我也在上编译原理，因此中间表示IR的翻译思想深刻影响了我，因此为了降低代码维护的复杂度，我先将.tm文件解析生成一种规范的易处理的格式，然后再在main函数中对这种类似OJ的输入进行解析并生成图灵机。实现起来非常流畅，且易维护。这就好比一下子爬不了那么高，但是我可以建造台阶或者梯子，让每一步变得相对容易实现。

(3) 对拍测试
test.py中的代码是随机对拍测试，测试情况如下：  
对于回文串、aibjaibj串以及一进制乘法串的测试：  
[1,100], [101,200],...,[901,1000]每个长度分段测试200组case，均通过测试。
在[1,10]长度分段测试1000组case，均通过测试。


Part III 实现两个图灵机程序
----

### L1: aibjaibj

以"aabaab"为例：  
使用二带图灵机，将第二个aab剪切到tape[1]，然后两个指针都从头开始进行比较。  
具体实现细节如下：
> q0: 初态，当且仅当tape[0]指向的符号为a时进入q1，其他情况reject。  
> q1: 识别第一段连续的a，如果读出的符号还是a，则继续；如果读出的符号是b，则进入q2；如果读出的符号是_，reject。  
> q2: 识别第一段连续的b，如果读出的符号还是b，则继续；如果读出的符号是a，则进入cp；如果读出的符号是_，reject。  
> cp: 将tape[0]未识别的后续所有字符剪切到tape[1]，剪切完毕后进入mh。  
> mh: 将两个指针指向第一个字符，然后进入cmp。  
> cmp: 逐个比较tape[0]和tape[1]的字符，一旦发现不同，reject；如果比到两个字符都是_，则accept。  
> accept: （保证tape[0]已空，且指向空白符）直接在tape[0]上写上"true"，进入halt_accept。  
> reject_left: （保证tape[0]指针右边已空）清空左边和当前位置的所有非空白符，进入reject。  
> reject_right: （保证tape[0]指针左边已空）清空右边和当前位置的所有非空白符，进入reject。  
> reject: （保证tape[0]已空，且指向空白符）直接在tape[0]上写上"false"，进入halt_reject。  


### L2: 一进制乘法

以"11x111=111111"为例：  
使用三带图灵机，tape[0]记录输入串，tape[1]记录第二个乘数，tape[2]记录乘积，即  
```cpp
tape[0]: 11x111=111111
         ^
tape[1]: 111
         ^
tape[2]: 111111
         ^
```
将tape[0]中的x作为边界，可以得到第一个乘数。  
每次删除tape[2]中个数等于tape[1]中1的个数的1，进行如下循环：  
如果tape[0]指针指向1，说明还需要删除，则从左至右遍历tape[1]，同时删除tape[2]中相同数量的1；  
如果tape[1]指针指向x，说明不需要删除，判断tape[1]和tape[2]的情况。  
```cpp
tape[0]: 11x111=111111
          ^
tape[1]: 111
         ^
tape[2]: ___111
            ^
```
```cpp
tape[0]: 11x111=111111
           ^
tape[1]: 111
         ^
tape[2]: _______
               ^
```
当然，有很多的边界情况，下面进行详细说明：  
> q0: 初态，当且仅当tape[0]字符是1才转到q1，否则reject。  
> q1: 读出第一个乘数。如果读出的字符为1，则继续往下读；如果读出的字符为x，转到q2；其他情况reject。  
> q2: 判断是否存在第二个乘数。如果读出的字符为1，转到q2a，其他情况reject。  
> q2a: 读出第二个乘数。如果读出的字符为1，则继续往下读；如果读出的字符为=，转到q3；其他情况reject。  
> q3: 判断是否存在乘积。如果读出的字符是1，转到q3a，其他情况reject。  
> q3a: 读出乘积。如果读出的字符为1，则继续往下读；如果读出的字符为_，转到mh（保证三个指针均指向最后一个1）；其他情况reject。  
> mh: 将三个指针按先tape[0]，再tape[1]，最后tape[2]的顺序依次左移到第一个位置，转到begin。  
> begin: 测试是否需要下一轮循环（保证tape[1]==1）。如果tape[0]==x,tape[1]==1,tape[2]==_转到accept；如果tape[0]==1,tape[1]==1,tape[2]==1转到round；其他情况reject。  
> round: tape[1]从左至右走一遍，tape[2]跟着走一遍，并消除同样数量的1，如果中途出现tape[2]中1的数量不够，则reject；如果tape[1]走完，则转到over。
> over: 一轮结束，将tape[0]的指针右移一位，准备tape[1]指针左移，转到return。  
> return: tape[1]指针左移到开头，转到begin。  
> accept: （保证tape[0]指向的符号非空白符）将tape[0]上的所有符号清空，并写上"true"，转到halt_accept。  
> reject: （保证tape[0]指向的符号非空白符）将tape[0]上的所有符号清空，并写上"false"，转到halt_reject。  
